/*
 Generated by typeshare 1.13.2
 */

import Foundation

public struct ApprovalData: Codable, Equatable, Hashable, Sendable {
	public let token: String
	public let spender: String
	public let value: String

	public init(token: String, spender: String, value: String) {
		self.token = token
		self.spender = spender
		self.value = value
	}
}

public struct QuoteAsset: Codable {
	public let id: String
	public let symbol: String
	public let decimals: UInt32

	public init(id: String, symbol: String, decimals: UInt32) {
		self.id = id
		self.symbol = symbol
		self.decimals = decimals
	}
}

public struct SwapProviderData: Codable, Equatable, Hashable, Sendable {
	public let provider: SwapProvider
	public let name: String
	public let protocolName: String

	public init(provider: SwapProvider, name: String, protocolName: String) {
		self.provider = provider
		self.name = name
		self.protocolName = protocolName
	}
}

public struct SwapQuote: Codable, Equatable, Hashable, Sendable {
	public let fromAddress: String
	public let fromValue: String
	public let toAddress: String
	public let toValue: String
	public let providerData: SwapProviderData
	public let slippageBps: UInt32
	public let etaInSeconds: UInt32?
	public let useMaxAmount: Bool?

	public init(fromAddress: String, fromValue: String, toAddress: String, toValue: String, providerData: SwapProviderData, slippageBps: UInt32, etaInSeconds: UInt32?, useMaxAmount: Bool?) {
		self.fromAddress = fromAddress
		self.fromValue = fromValue
		self.toAddress = toAddress
		self.toValue = toValue
		self.providerData = providerData
		self.slippageBps = slippageBps
		self.etaInSeconds = etaInSeconds
		self.useMaxAmount = useMaxAmount
	}
}

public enum SwapQuoteDataType: String, Codable, Equatable, Hashable, Sendable {
	case contract
	case transfer
}

public struct SwapQuoteData: Codable, Equatable, Hashable, Sendable {
	public let to: String
	public let dataType: SwapQuoteDataType
	public let value: String
	public let data: String
	public let memo: String?
	public let approval: ApprovalData?
	public let gasLimit: String?

	public init(to: String, dataType: SwapQuoteDataType, value: String, data: String, memo: String?, approval: ApprovalData?, gasLimit: String?) {
		self.to = to
		self.dataType = dataType
		self.value = value
		self.data = data
		self.memo = memo
		self.approval = approval
		self.gasLimit = gasLimit
	}
}

public struct SwapData: Codable, Equatable, Hashable, Sendable {
	public let quote: SwapQuote
	public let data: SwapQuoteData

	public init(quote: SwapQuote, data: SwapQuoteData) {
		self.quote = quote
		self.data = data
	}
}

public enum SwapStatus: String, Codable, Equatable, Hashable, Sendable {
	case pending
	case completed
	case failed
	case refunded
}
