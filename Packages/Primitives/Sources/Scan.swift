/*
 Generated by typeshare 1.13.2
 */

import Foundation

public enum AddressType: String, Codable, Equatable, Sendable {
	case address
	case contract
	case validator
}

public struct ScanAddress: Codable, Equatable, Sendable {
	public let chain: Chain
	public let address: String
	public let name: String?
	public let type: AddressType?
	public let isMalicious: Bool?
	public let isMemoRequired: Bool?
	public let isVerified: Bool?

	public init(chain: Chain, address: String, name: String?, type: AddressType?, isMalicious: Bool?, isMemoRequired: Bool?, isVerified: Bool?) {
		self.chain = chain
		self.address = address
		self.name = name
		self.type = type
		self.isMalicious = isMalicious
		self.isMemoRequired = isMemoRequired
		self.isVerified = isVerified
	}
}

public struct ScanAddressTarget: Codable, Equatable, Sendable {
	public let chain: Chain
	public let address: String

	public init(chain: Chain, address: String) {
		self.chain = chain
		self.address = address
	}
}

public struct ScanTransaction: Codable, Equatable, Sendable {
	public let isMalicious: Bool
	public let isMemoRequired: Bool

	public init(isMalicious: Bool, isMemoRequired: Bool) {
		self.isMalicious = isMalicious
		self.isMemoRequired = isMemoRequired
	}
}

public struct ScanTransactionPayload: Codable, Equatable, Sendable {
	public let deviceId: String
	public let walletIndex: UInt32
	public let origin: ScanAddressTarget
	public let target: ScanAddressTarget
	public let website: String?
	public let type: TransactionType

	public init(deviceId: String, walletIndex: UInt32, origin: ScanAddressTarget, target: ScanAddressTarget, website: String?, type: TransactionType) {
		self.deviceId = deviceId
		self.walletIndex = walletIndex
		self.origin = origin
		self.target = target
		self.website = website
		self.type = type
	}
}
