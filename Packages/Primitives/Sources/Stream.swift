/*
 Generated by typeshare 1.13.3
 */

import Foundation

public struct StreamBalanceUpdate: Codable, Sendable {
	public let walletId: WalletId
	public let chain: Chain
	public let address: String
	public let assetId: AssetId

	public init(walletId: WalletId, chain: Chain, address: String, assetId: AssetId) {
		self.walletId = walletId
		self.chain = chain
		self.address = address
		self.assetId = assetId
	}
}

public struct StreamTransactionsUpdate: Codable, Sendable {
	public let walletId: WalletId
	public let transactions: [Transaction]

	public init(walletId: WalletId, transactions: [Transaction]) {
		self.walletId = walletId
		self.transactions = transactions
	}
}

public enum StreamEvent: Codable, Sendable {
	case prices(WebSocketPricePayload)
	case balances([StreamBalanceUpdate])
	case transactions(StreamTransactionsUpdate)

	enum CodingKeys: String, CodingKey, Codable {
		case prices,
			balances,
			transactions
	}

	private enum ContainerCodingKeys: String, CodingKey {
		case event, data
	}

	public init(from decoder: Decoder) throws {
		let container = try decoder.container(keyedBy: ContainerCodingKeys.self)
		if let type = try? container.decode(CodingKeys.self, forKey: .event) {
			switch type {
			case .prices:
				if let content = try? container.decode(WebSocketPricePayload.self, forKey: .data) {
					self = .prices(content)
					return
				}
			case .balances:
				if let content = try? container.decode([StreamBalanceUpdate].self, forKey: .data) {
					self = .balances(content)
					return
				}
			case .transactions:
				if let content = try? container.decode(StreamTransactionsUpdate.self, forKey: .data) {
					self = .transactions(content)
					return
				}
			}
		}
		throw DecodingError.typeMismatch(StreamEvent.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for StreamEvent"))
	}

	public func encode(to encoder: Encoder) throws {
		var container = encoder.container(keyedBy: ContainerCodingKeys.self)
		switch self {
		case .prices(let content):
			try container.encode(CodingKeys.prices, forKey: .event)
			try container.encode(content, forKey: .data)
		case .balances(let content):
			try container.encode(CodingKeys.balances, forKey: .event)
			try container.encode(content, forKey: .data)
		case .transactions(let content):
			try container.encode(CodingKeys.transactions, forKey: .event)
			try container.encode(content, forKey: .data)
		}
	}
}


/// Generated type representing the anonymous struct variant `SubscribePrices` of the `StreamMessage` Rust enum
public struct StreamMessageSubscribePricesInner: Codable, Sendable {
	public let assets: [AssetId]?

	public init(assets: [AssetId]?) {
		self.assets = assets
	}
}

/// Generated type representing the anonymous struct variant `UnsubscribePrices` of the `StreamMessage` Rust enum
public struct StreamMessageUnsubscribePricesInner: Codable, Sendable {
	public let assets: [AssetId]?

	public init(assets: [AssetId]?) {
		self.assets = assets
	}
}

/// Generated type representing the anonymous struct variant `AddPrices` of the `StreamMessage` Rust enum
public struct StreamMessageAddPricesInner: Codable, Sendable {
	public let assets: [AssetId]?

	public init(assets: [AssetId]?) {
		self.assets = assets
	}
}
public enum StreamMessage: Codable, Sendable {
	case subscribePrices(StreamMessageSubscribePricesInner)
	case unsubscribePrices(StreamMessageUnsubscribePricesInner)
	case addPrices(StreamMessageAddPricesInner)

	enum CodingKeys: String, CodingKey, Codable {
		case subscribePrices,
			unsubscribePrices,
			addPrices
	}

	private enum ContainerCodingKeys: String, CodingKey {
		case type, data
	}

	public init(from decoder: Decoder) throws {
		let container = try decoder.container(keyedBy: ContainerCodingKeys.self)
		if let type = try? container.decode(CodingKeys.self, forKey: .type) {
			switch type {
			case .subscribePrices:
				if let content = try? container.decode(StreamMessageSubscribePricesInner.self, forKey: .data) {
					self = .subscribePrices(content)
					return
				}
			case .unsubscribePrices:
				if let content = try? container.decode(StreamMessageUnsubscribePricesInner.self, forKey: .data) {
					self = .unsubscribePrices(content)
					return
				}
			case .addPrices:
				if let content = try? container.decode(StreamMessageAddPricesInner.self, forKey: .data) {
					self = .addPrices(content)
					return
				}
			}
		}
		throw DecodingError.typeMismatch(StreamMessage.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for StreamMessage"))
	}

	public func encode(to encoder: Encoder) throws {
		var container = encoder.container(keyedBy: ContainerCodingKeys.self)
		switch self {
		case .subscribePrices(let content):
			try container.encode(CodingKeys.subscribePrices, forKey: .type)
			try container.encode(content, forKey: .data)
		case .unsubscribePrices(let content):
			try container.encode(CodingKeys.unsubscribePrices, forKey: .type)
			try container.encode(content, forKey: .data)
		case .addPrices(let content):
			try container.encode(CodingKeys.addPrices, forKey: .type)
			try container.encode(content, forKey: .data)
		}
	}
}
