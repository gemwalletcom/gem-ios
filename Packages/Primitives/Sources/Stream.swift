/*
 Generated by typeshare 1.13.3
 */

import Foundation

public struct StreamBalanceUpdate: Codable, Sendable {
	public let walletId: WalletId
	public let assetId: AssetId

	public init(walletId: WalletId, assetId: AssetId) {
		self.walletId = walletId
		self.assetId = assetId
	}
}

public struct StreamMessagePrices: Codable, Sendable {
	public let assets: [AssetId]

	public init(assets: [AssetId]) {
		self.assets = assets
	}
}

public struct StreamNewAssetsUpdate: Codable, Sendable {
	public let walletId: WalletId
	public let assets: [AssetId]

	public init(walletId: WalletId, assets: [AssetId]) {
		self.walletId = walletId
		self.assets = assets
	}
}

public struct StreamNftUpdate: Codable, Sendable {
	public let walletId: WalletId

	public init(walletId: WalletId) {
		self.walletId = walletId
	}
}

public struct StreamNotificationlUpdate: Codable, Sendable {
	public let walletId: WalletId
	public let notification: InAppNotification

	public init(walletId: WalletId, notification: InAppNotification) {
		self.walletId = walletId
		self.notification = notification
	}
}

public struct StreamPerpetualUpdate: Codable, Sendable {
	public let walletId: WalletId

	public init(walletId: WalletId) {
		self.walletId = walletId
	}
}

public struct StreamPriceAlertUpdate: Codable, Sendable {
	public let assets: [AssetId]

	public init(assets: [AssetId]) {
		self.assets = assets
	}
}

public struct StreamTransactionsUpdate: Codable, Sendable {
	public let walletId: WalletId
	public let transactions: [TransactionId]

	public init(walletId: WalletId, transactions: [TransactionId]) {
		self.walletId = walletId
		self.transactions = transactions
	}
}

public enum StreamEvent: Codable, Sendable {
	case prices(WebSocketPricePayload)
	case balances([StreamBalanceUpdate])
	case transactions(StreamTransactionsUpdate)
	case priceAlerts(StreamPriceAlertUpdate)
	case nft(StreamNftUpdate)
	case perpetual(StreamPerpetualUpdate)
	case inAppNotification(StreamNotificationlUpdate)
	case newAssets(StreamNewAssetsUpdate)

	enum CodingKeys: String, CodingKey, Codable {
		case prices,
			balances,
			transactions,
			priceAlerts,
			nft,
			perpetual,
			inAppNotification,
			newAssets
	}

	private enum ContainerCodingKeys: String, CodingKey {
		case event, data
	}

	public init(from decoder: Decoder) throws {
		let container = try decoder.container(keyedBy: ContainerCodingKeys.self)
		if let type = try? container.decode(CodingKeys.self, forKey: .event) {
			switch type {
			case .prices:
				if let content = try? container.decode(WebSocketPricePayload.self, forKey: .data) {
					self = .prices(content)
					return
				}
			case .balances:
				if let content = try? container.decode([StreamBalanceUpdate].self, forKey: .data) {
					self = .balances(content)
					return
				}
			case .transactions:
				if let content = try? container.decode(StreamTransactionsUpdate.self, forKey: .data) {
					self = .transactions(content)
					return
				}
			case .priceAlerts:
				if let content = try? container.decode(StreamPriceAlertUpdate.self, forKey: .data) {
					self = .priceAlerts(content)
					return
				}
			case .nft:
				if let content = try? container.decode(StreamNftUpdate.self, forKey: .data) {
					self = .nft(content)
					return
				}
			case .perpetual:
				if let content = try? container.decode(StreamPerpetualUpdate.self, forKey: .data) {
					self = .perpetual(content)
					return
				}
			case .inAppNotification:
				if let content = try? container.decode(StreamNotificationlUpdate.self, forKey: .data) {
					self = .inAppNotification(content)
					return
				}
			case .newAssets:
				if let content = try? container.decode(StreamNewAssetsUpdate.self, forKey: .data) {
					self = .newAssets(content)
					return
				}
			}
		}
		throw DecodingError.typeMismatch(StreamEvent.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for StreamEvent"))
	}

	public func encode(to encoder: Encoder) throws {
		var container = encoder.container(keyedBy: ContainerCodingKeys.self)
		switch self {
		case .prices(let content):
			try container.encode(CodingKeys.prices, forKey: .event)
			try container.encode(content, forKey: .data)
		case .balances(let content):
			try container.encode(CodingKeys.balances, forKey: .event)
			try container.encode(content, forKey: .data)
		case .transactions(let content):
			try container.encode(CodingKeys.transactions, forKey: .event)
			try container.encode(content, forKey: .data)
		case .priceAlerts(let content):
			try container.encode(CodingKeys.priceAlerts, forKey: .event)
			try container.encode(content, forKey: .data)
		case .nft(let content):
			try container.encode(CodingKeys.nft, forKey: .event)
			try container.encode(content, forKey: .data)
		case .perpetual(let content):
			try container.encode(CodingKeys.perpetual, forKey: .event)
			try container.encode(content, forKey: .data)
		case .inAppNotification(let content):
			try container.encode(CodingKeys.inAppNotification, forKey: .event)
			try container.encode(content, forKey: .data)
		case .newAssets(let content):
			try container.encode(CodingKeys.newAssets, forKey: .event)
			try container.encode(content, forKey: .data)
		}
	}
}

public enum StreamMessage: Codable, Sendable {
	case subscribePrices(StreamMessagePrices)
	case unsubscribePrices(StreamMessagePrices)
	case addPrices(StreamMessagePrices)
	case subscribeRealtimePrices(StreamMessagePrices)
	case unsubscribeRealtimePrices(StreamMessagePrices)

	enum CodingKeys: String, CodingKey, Codable {
		case subscribePrices,
			unsubscribePrices,
			addPrices,
			subscribeRealtimePrices,
			unsubscribeRealtimePrices
	}

	private enum ContainerCodingKeys: String, CodingKey {
		case type, data
	}

	public init(from decoder: Decoder) throws {
		let container = try decoder.container(keyedBy: ContainerCodingKeys.self)
		if let type = try? container.decode(CodingKeys.self, forKey: .type) {
			switch type {
			case .subscribePrices:
				if let content = try? container.decode(StreamMessagePrices.self, forKey: .data) {
					self = .subscribePrices(content)
					return
				}
			case .unsubscribePrices:
				if let content = try? container.decode(StreamMessagePrices.self, forKey: .data) {
					self = .unsubscribePrices(content)
					return
				}
			case .addPrices:
				if let content = try? container.decode(StreamMessagePrices.self, forKey: .data) {
					self = .addPrices(content)
					return
				}
			case .subscribeRealtimePrices:
				if let content = try? container.decode(StreamMessagePrices.self, forKey: .data) {
					self = .subscribeRealtimePrices(content)
					return
				}
			case .unsubscribeRealtimePrices:
				if let content = try? container.decode(StreamMessagePrices.self, forKey: .data) {
					self = .unsubscribeRealtimePrices(content)
					return
				}
			}
		}
		throw DecodingError.typeMismatch(StreamMessage.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for StreamMessage"))
	}

	public func encode(to encoder: Encoder) throws {
		var container = encoder.container(keyedBy: ContainerCodingKeys.self)
		switch self {
		case .subscribePrices(let content):
			try container.encode(CodingKeys.subscribePrices, forKey: .type)
			try container.encode(content, forKey: .data)
		case .unsubscribePrices(let content):
			try container.encode(CodingKeys.unsubscribePrices, forKey: .type)
			try container.encode(content, forKey: .data)
		case .addPrices(let content):
			try container.encode(CodingKeys.addPrices, forKey: .type)
			try container.encode(content, forKey: .data)
		case .subscribeRealtimePrices(let content):
			try container.encode(CodingKeys.subscribeRealtimePrices, forKey: .type)
			try container.encode(content, forKey: .data)
		case .unsubscribeRealtimePrices(let content):
			try container.encode(CodingKeys.unsubscribeRealtimePrices, forKey: .type)
			try container.encode(content, forKey: .data)
		}
	}
}
