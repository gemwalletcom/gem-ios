/*
 Generated by typeshare 1.11.0
 */

import Foundation

public struct NFTImage: Codable, Sendable {
	public let imageUrl: String
	public let previewImageUrl: String
	public let originalSourceUrl: String

	public init(imageUrl: String, previewImageUrl: String, originalSourceUrl: String) {
		self.imageUrl = imageUrl
		self.previewImageUrl = previewImageUrl
		self.originalSourceUrl = originalSourceUrl
	}
}

public enum NFTType: String, Codable, Sendable {
	case erc721
	case erc1155
	case spl
}

public struct NFTAttrubute: Codable, Sendable {
	public let name: String
	public let value: String

	public init(name: String, value: String) {
		self.name = name
		self.value = value
	}
}

public struct NFTAsset: Codable, Sendable {
	public let id: String
	public let name: String
	public let description: String?
	public let chain: Chain
	public let image: NFTImage
	public let type: NFTType
	public let attributes: [NFTAttrubute]

	public init(id: String, name: String, description: String?, chain: Chain, image: NFTImage, type: NFTType, attributes: [NFTAttrubute]) {
		self.id = id
		self.name = name
		self.description = description
		self.chain = chain
		self.image = image
		self.type = type
		self.attributes = attributes
	}
}

public struct NFTCollection: Codable, Sendable {
	public let id: String
	public let name: String
	public let description: String?
	public let chain: Chain
	public let image: NFTImage
	public let isVerified: Bool

	public init(id: String, name: String, description: String?, chain: Chain, image: NFTImage, isVerified: Bool) {
		self.id = id
		self.name = name
		self.description = description
		self.chain = chain
		self.image = image
		self.isVerified = isVerified
	}
}

public struct NFTResult: Codable, Sendable {
	public let collection: NFTCollection
	public let assets: [NFTAsset]

	public init(collection: NFTCollection, assets: [NFTAsset]) {
		self.collection = collection
		self.assets = assets
	}
}
