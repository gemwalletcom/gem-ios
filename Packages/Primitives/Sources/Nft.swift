/*
 Generated by typeshare 1.13.3
 */

import Foundation

public enum NFTType: String, Codable, Equatable, Hashable, Sendable {
	case erc721
	case erc1155
	case spl
	case jetton
}

public struct NFTResource: Codable, Equatable, Hashable, Sendable {
	public let url: String
	public let mimeType: String

	public init(url: String, mimeType: String) {
		self.url = url
		self.mimeType = mimeType
	}
}

public struct NFTImages: Codable, Equatable, Hashable, Sendable {
	public let preview: NFTResource

	public init(preview: NFTResource) {
		self.preview = preview
	}
}

public struct NFTAttribute: Codable, Equatable, Hashable, Sendable {
	public let name: String
	public let value: String
	public let percentage: Double?

	public init(name: String, value: String, percentage: Double?) {
		self.name = name
		self.value = value
		self.percentage = percentage
	}
}

public struct NFTAsset: Codable, Equatable, Hashable, Identifiable, Sendable {
	public let id: String
	public let collectionId: String
	public let contractAddress: String?
	public let tokenId: String
	public let tokenType: NFTType
	public let name: String
	public let description: String?
	public let chain: Chain
	public let resource: NFTResource
	public let images: NFTImages
	public let attributes: [NFTAttribute]

	public init(id: String, collectionId: String, contractAddress: String?, tokenId: String, tokenType: NFTType, name: String, description: String?, chain: Chain, resource: NFTResource, images: NFTImages, attributes: [NFTAttribute]) {
		self.id = id
		self.collectionId = collectionId
		self.contractAddress = contractAddress
		self.tokenId = tokenId
		self.tokenType = tokenType
		self.name = name
		self.description = description
		self.chain = chain
		self.resource = resource
		self.images = images
		self.attributes = attributes
	}
}

public struct NFTCollection: Codable, Equatable, Hashable, Identifiable, Sendable {
	public let id: String
	public let name: String
	public let description: String?
	public let chain: Chain
	public let contractAddress: String
	public let images: NFTImages
	public let isVerified: Bool
	public let links: [AssetLink]

	public init(id: String, name: String, description: String?, chain: Chain, contractAddress: String, images: NFTImages, isVerified: Bool, links: [AssetLink]) {
		self.id = id
		self.name = name
		self.description = description
		self.chain = chain
		self.contractAddress = contractAddress
		self.images = images
		self.isVerified = isVerified
		self.links = links
	}
}

public struct NFTAssetData: Codable, Equatable, Hashable, Sendable {
	public let collection: NFTCollection
	public let asset: NFTAsset

	public init(collection: NFTCollection, asset: NFTAsset) {
		self.collection = collection
		self.asset = asset
	}
}

public struct NFTAssetId: Codable, Equatable, Hashable, Sendable {
	public let chain: Chain
	public let contractAddress: String
	public let tokenId: String

	public init(chain: Chain, contractAddress: String, tokenId: String) {
		self.chain = chain
		self.contractAddress = contractAddress
		self.tokenId = tokenId
	}
}

public struct NFTData: Codable, Equatable, Hashable, Sendable {
	public let collection: NFTCollection
	public let assets: [NFTAsset]

	public init(collection: NFTCollection, assets: [NFTAsset]) {
		self.collection = collection
		self.assets = assets
	}
}

public struct ReportNft: Codable, Sendable {
	public let deviceId: String
	public let collectionId: String
	public let assetId: String?
	public let reason: String?

	public init(deviceId: String, collectionId: String, assetId: String?, reason: String?) {
		self.deviceId = deviceId
		self.collectionId = collectionId
		self.assetId = assetId
		self.reason = reason
	}
}

public enum ReportReason: String, Codable, CaseIterable, Sendable {
	case spam
	case malicious
	case inappropriate
	case copyright
	case other
}
