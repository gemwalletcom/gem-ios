/*
 Generated by typeshare 1.13.3
 */

import Foundation

public enum FreezeType: String, Codable, Equatable, Hashable, Sendable {
	case freeze
	case unfreeze
}

public enum Resource: String, Codable, Equatable, Hashable, Sendable {
	case bandwidth
	case energy
}

public struct FreezeData: Codable, Equatable, Hashable, Sendable {
	public let freezeType: FreezeType
	public let resource: Resource

	public init(freezeType: FreezeType, resource: Resource) {
		self.freezeType = freezeType
		self.resource = resource
	}
}

public struct RedelegateData: Codable, Equatable, Hashable, Sendable {
	public let delegation: Delegation
	public let toValidator: DelegationValidator

	public init(delegation: Delegation, toValidator: DelegationValidator) {
		self.delegation = delegation
		self.toValidator = toValidator
	}
}

public struct StakeData: Codable, Equatable, Hashable, Sendable {
	public let data: String?
	public let to: String?

	public init(data: String?, to: String?) {
		self.data = data
		self.to = to
	}
}

public enum StakeType: Codable, Equatable, Hashable, Sendable {
	case stake(DelegationValidator)
	case unstake(Delegation)
	case redelegate(RedelegateData)
	case rewards([DelegationValidator])
	case withdraw(Delegation)
	case freeze(FreezeData)

	enum CodingKeys: String, CodingKey, Codable {
		case stake = "Stake",
			unstake = "Unstake",
			redelegate = "Redelegate",
			rewards = "Rewards",
			withdraw = "Withdraw",
			freeze = "Freeze"
	}

	private enum ContainerCodingKeys: String, CodingKey {
		case type, content
	}

	public init(from decoder: Decoder) throws {
		let container = try decoder.container(keyedBy: ContainerCodingKeys.self)
		if let type = try? container.decode(CodingKeys.self, forKey: .type) {
			switch type {
			case .stake:
				if let content = try? container.decode(DelegationValidator.self, forKey: .content) {
					self = .stake(content)
					return
				}
			case .unstake:
				if let content = try? container.decode(Delegation.self, forKey: .content) {
					self = .unstake(content)
					return
				}
			case .redelegate:
				if let content = try? container.decode(RedelegateData.self, forKey: .content) {
					self = .redelegate(content)
					return
				}
			case .rewards:
				if let content = try? container.decode([DelegationValidator].self, forKey: .content) {
					self = .rewards(content)
					return
				}
			case .withdraw:
				if let content = try? container.decode(Delegation.self, forKey: .content) {
					self = .withdraw(content)
					return
				}
			case .freeze:
				if let content = try? container.decode(FreezeData.self, forKey: .content) {
					self = .freeze(content)
					return
				}
			}
		}
		throw DecodingError.typeMismatch(StakeType.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for StakeType"))
	}

	public func encode(to encoder: Encoder) throws {
		var container = encoder.container(keyedBy: ContainerCodingKeys.self)
		switch self {
		case .stake(let content):
			try container.encode(CodingKeys.stake, forKey: .type)
			try container.encode(content, forKey: .content)
		case .unstake(let content):
			try container.encode(CodingKeys.unstake, forKey: .type)
			try container.encode(content, forKey: .content)
		case .redelegate(let content):
			try container.encode(CodingKeys.redelegate, forKey: .type)
			try container.encode(content, forKey: .content)
		case .rewards(let content):
			try container.encode(CodingKeys.rewards, forKey: .type)
			try container.encode(content, forKey: .content)
		case .withdraw(let content):
			try container.encode(CodingKeys.withdraw, forKey: .type)
			try container.encode(content, forKey: .content)
		case .freeze(let content):
			try container.encode(CodingKeys.freeze, forKey: .type)
			try container.encode(content, forKey: .content)
		}
	}
}
