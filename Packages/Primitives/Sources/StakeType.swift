/*
 Generated by typeshare 1.13.3
 */

import Foundation

public enum FreezeType: String, Codable, Equatable, Hashable, Sendable {
	case freeze
	case unfreeze
}

public enum Resource: String, Codable, Equatable, Hashable, Sendable {
	case bandwidth
	case energy
}

public struct FreezeData: Codable, Equatable, Hashable, Sendable {
	public let freezeType: FreezeType
	public let resource: Resource

	public init(freezeType: FreezeType, resource: Resource) {
		self.freezeType = freezeType
		self.resource = resource
	}
}

public struct RedelegateData: Codable, Equatable, Hashable, Sendable {
	public let delegation: Delegation
	public let toValidator: DelegationValidator

	public init(delegation: Delegation, toValidator: DelegationValidator) {
		self.delegation = delegation
		self.toValidator = toValidator
	}
}

public struct ContractCallData: Codable, Equatable, Hashable, Sendable {
	public let contractAddress: String
	public let callData: String
	public let approval: ApprovalData?
	public let gasLimit: String?

	public init(contractAddress: String, callData: String, approval: ApprovalData? = nil, gasLimit: String? = nil) {
		self.contractAddress = contractAddress
		self.callData = callData
		self.approval = approval
		self.gasLimit = gasLimit
	}
}

public struct TronUnfreeze: Codable, Equatable, Hashable, Sendable {
	public let resource: Resource
	public let amount: UInt64

	public init(resource: Resource, amount: UInt64) {
		self.resource = resource
		self.amount = amount
	}
}

public struct TronVote: Codable, Equatable, Hashable, Sendable {
	public let validator: String
	public let count: UInt64

	public init(validator: String, count: UInt64) {
		self.validator = validator
		self.count = count
	}
}

public enum StakeType: Codable, Equatable, Hashable, Sendable {
	case stake(DelegationValidator)
	case unstake(Delegation)
	case redelegate(RedelegateData)
	case rewards([DelegationValidator])
	case withdraw(Delegation)
	case freeze(FreezeData)

	enum CodingKeys: String, CodingKey, Codable {
		case stake = "Stake",
			unstake = "Unstake",
			redelegate = "Redelegate",
			rewards = "Rewards",
			withdraw = "Withdraw",
			freeze = "Freeze"
	}

	private enum ContainerCodingKeys: String, CodingKey {
		case type, content
	}

	public init(from decoder: Decoder) throws {
		let container = try decoder.container(keyedBy: ContainerCodingKeys.self)
		if let type = try? container.decode(CodingKeys.self, forKey: .type) {
			switch type {
			case .stake:
				if let content = try? container.decode(DelegationValidator.self, forKey: .content) {
					self = .stake(content)
					return
				}
			case .unstake:
				if let content = try? container.decode(Delegation.self, forKey: .content) {
					self = .unstake(content)
					return
				}
			case .redelegate:
				if let content = try? container.decode(RedelegateData.self, forKey: .content) {
					self = .redelegate(content)
					return
				}
			case .rewards:
				if let content = try? container.decode([DelegationValidator].self, forKey: .content) {
					self = .rewards(content)
					return
				}
			case .withdraw:
				if let content = try? container.decode(Delegation.self, forKey: .content) {
					self = .withdraw(content)
					return
				}
			case .freeze:
				if let content = try? container.decode(FreezeData.self, forKey: .content) {
					self = .freeze(content)
					return
				}
			}
		}
		throw DecodingError.typeMismatch(StakeType.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for StakeType"))
	}

	public func encode(to encoder: Encoder) throws {
		var container = encoder.container(keyedBy: ContainerCodingKeys.self)
		switch self {
		case .stake(let content):
			try container.encode(CodingKeys.stake, forKey: .type)
			try container.encode(content, forKey: .content)
		case .unstake(let content):
			try container.encode(CodingKeys.unstake, forKey: .type)
			try container.encode(content, forKey: .content)
		case .redelegate(let content):
			try container.encode(CodingKeys.redelegate, forKey: .type)
			try container.encode(content, forKey: .content)
		case .rewards(let content):
			try container.encode(CodingKeys.rewards, forKey: .type)
			try container.encode(content, forKey: .content)
		case .withdraw(let content):
			try container.encode(CodingKeys.withdraw, forKey: .type)
			try container.encode(content, forKey: .content)
		case .freeze(let content):
			try container.encode(CodingKeys.freeze, forKey: .type)
			try container.encode(content, forKey: .content)
		}
	}
}

public enum TronStakeData: Codable, Equatable, Hashable, Sendable {
	case votes([TronVote])
	case unfreeze([TronUnfreeze])

	enum CodingKeys: String, CodingKey, Codable {
		case votes = "Votes",
			unfreeze = "Unfreeze"
	}

	private enum ContainerCodingKeys: String, CodingKey {
		case type, content
	}

	public init(from decoder: Decoder) throws {
		let container = try decoder.container(keyedBy: ContainerCodingKeys.self)
		if let type = try? container.decode(CodingKeys.self, forKey: .type) {
			switch type {
			case .votes:
				if let content = try? container.decode([TronVote].self, forKey: .content) {
					self = .votes(content)
					return
				}
			case .unfreeze:
				if let content = try? container.decode([TronUnfreeze].self, forKey: .content) {
					self = .unfreeze(content)
					return
				}
			}
		}
		throw DecodingError.typeMismatch(TronStakeData.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for TronStakeData"))
	}

	public func encode(to encoder: Encoder) throws {
		var container = encoder.container(keyedBy: ContainerCodingKeys.self)
		switch self {
		case .votes(let content):
			try container.encode(CodingKeys.votes, forKey: .type)
			try container.encode(content, forKey: .content)
		case .unfreeze(let content):
			try container.encode(CodingKeys.unfreeze, forKey: .type)
			try container.encode(content, forKey: .content)
		}
	}
}
