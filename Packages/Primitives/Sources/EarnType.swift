/*
 Generated by typeshare 1.13.3
 */

import Foundation

public struct EarnTransaction: Codable, Sendable {
	public let chain: Chain
	public let from: String
	public let to: String
	public let data: String
	public let value: String?
	public let approval: ApprovalData?

	public init(chain: Chain, from: String, to: String, data: String, value: String?, approval: ApprovalData?) {
		self.chain = chain
		self.from = from
		self.to = to
		self.data = data
		self.value = value
		self.approval = approval
	}
}

public enum EarnType: Codable, Equatable, Hashable, Sendable {
	case deposit(DelegationValidator)
	case withdraw(Delegation)

	enum CodingKeys: String, CodingKey, Codable {
		case deposit = "Deposit",
			withdraw = "Withdraw"
	}

	private enum ContainerCodingKeys: String, CodingKey {
		case type, content
	}

	public init(from decoder: Decoder) throws {
		let container = try decoder.container(keyedBy: ContainerCodingKeys.self)
		if let type = try? container.decode(CodingKeys.self, forKey: .type) {
			switch type {
			case .deposit:
				if let content = try? container.decode(DelegationValidator.self, forKey: .content) {
					self = .deposit(content)
					return
				}
			case .withdraw:
				if let content = try? container.decode(Delegation.self, forKey: .content) {
					self = .withdraw(content)
					return
				}
			}
		}
		throw DecodingError.typeMismatch(EarnType.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for EarnType"))
	}

	public func encode(to encoder: Encoder) throws {
		var container = encoder.container(keyedBy: ContainerCodingKeys.self)
		switch self {
		case .deposit(let content):
			try container.encode(CodingKeys.deposit, forKey: .type)
			try container.encode(content, forKey: .content)
		case .withdraw(let content):
			try container.encode(CodingKeys.withdraw, forKey: .type)
			try container.encode(content, forKey: .content)
		}
	}
}
